#!/usr/bin/env python3
"""
AWS Site-to-Site VPN Manager
Focused VPN configuration, monitoring, and automated remediation tool

Features:
- VPN configuration generation and deployment
- Automated connectivity testing (ping remote devices)
- Continuous health monitoring
- Automated issue detection and remediation
- Email notifications for issues
- Systemd service integration
"""

import argparse
import json
import sys
import subprocess
import re
import os
import smtplib
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from collections import defaultdict

class VPNConfig:
    """VPN Configuration Management"""
    
    def __init__(self):
        self.vpn_id = None
        self.tunnel_count = 2
        self.aws_peer_ips = []  # Outside IPs
        self.onprem_peer_ip = None  # Outside IP
        self.aws_inside_ips = []  # BGP inside IPs (169.254.x.x)
        self.onprem_inside_ips = []  # BGP inside IPs (169.254.x.x)
        self.aws_asn = 64512
        self.onprem_asn = 65000
        self.remote_networks = []  # Networks to ping/test
        self.psk = {}  # PSK per tunnel
        
    def load_from_file(self, filepath: str):
        """Load configuration from JSON file"""
        with open(filepath, 'r') as f:
            data = json.load(f)
        
        self.vpn_id = data.get('vpn_id')
        self.tunnel_count = data.get('tunnel_count', 2)
        self.aws_peer_ips = data.get('aws_peer_ips', [])
        self.onprem_peer_ip = data.get('onprem_peer_ip')
        self.aws_inside_ips = data.get('aws_inside_ips', [])
        self.onprem_inside_ips = data.get('onprem_inside_ips', [])
        self.aws_asn = data.get('aws_asn', 64512)
        self.onprem_asn = data.get('onprem_asn', 65000)
        self.remote_networks = data.get('remote_networks', [])
        self.psk = data.get('psk', {})
    
    def save_to_file(self, filepath: str):
        """Save configuration to JSON file"""
        data = {
            'vpn_id': self.vpn_id,
            'tunnel_count': self.tunnel_count,
            'aws_peer_ips': self.aws_peer_ips,
            'onprem_peer_ip': self.onprem_peer_ip,
            'aws_inside_ips': self.aws_inside_ips,
            'onprem_inside_ips': self.onprem_inside_ips,
            'aws_asn': self.aws_asn,
            'onprem_asn': self.onprem_asn,
            'remote_networks': self.remote_networks,
            'psk': self.psk
        }
        
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)
    
    def generate_configs(self, output_dir: str = '/etc/vpn'):
        """Generate all VPN configuration files"""
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        configs = {
            'ipsec.conf': self._generate_ipsec_conf(),
            'ipsec.secrets': self._generate_ipsec_secrets(),
            'frr.conf': self._generate_frr_conf(),
            'setup_vti.sh': self._generate_vti_script(),
            'aws-updown.sh': self._generate_updown_script()
        }
        
        for filename, content in configs.items():
            filepath = Path(output_dir) / filename
            with open(filepath, 'w') as f:
                f.write(content)
            
            # Make scripts executable
            if filename.endswith('.sh'):
                os.chmod(filepath, 0o755)
        
        return configs
    
    def _generate_ipsec_conf(self) -> str:
        """Generate IPsec configuration"""
        config = """# AWS Site-to-Site VPN Configuration
# Generated by VPN Manager

config setup
    charondebug="ike 2, knl 2, cfg 2, net 2, esp 2, dmn 2, mgr 2"
    uniqueids=no

"""
        for i, aws_ip in enumerate(self.aws_peer_ips, 1):
            config += f"""
conn Tunnel{i}
    auto=start
    left=%defaultroute
    leftid={self.onprem_peer_ip}
    leftauth=psk
    right={aws_ip}
    rightauth=psk
    type=tunnel
    ikelifetime=8h
    keylife=1h
    rekeymargin=3m
    keyingtries=%forever
    keyexchange=ikev1
    ike=aes128-sha1-modp1024
    esp=aes128-sha1-modp1024
    dpdaction=restart
    dpddelay=10s
    dpdtimeout=30s
    leftupdown=/etc/ipsec.d/aws-updown.sh
    mark={i}
    replay_window=128
"""
        return config
    
    def _generate_ipsec_secrets(self) -> str:
        """Generate IPsec secrets"""
        config = "# IPsec Secrets - Generated by VPN Manager\n\n"
        
        for i, aws_ip in enumerate(self.aws_peer_ips, 1):
            psk = self.psk.get(f'tunnel{i}', 'YOUR_PRE_SHARED_KEY')
            config += f"{self.onprem_peer_ip} {aws_ip} : PSK \"{psk}\"\n"
        
        return config
    
    def _generate_frr_conf(self) -> str:
        """Generate FRR BGP configuration"""
        # Use configured router ID or fall back to onprem_peer_ip
        router_id = self.onprem_peer_ip
        
        config = f"""# FRR BGP Configuration - Generated by VPN Manager

frr version 8.0
frr defaults traditional
hostname vpn-gateway
log syslog informational
no ipv6 forwarding
service integrated-vtysh-config

router bgp {self.onprem_asn}
 bgp router-id {router_id}
 bgp log-neighbor-changes
 no bgp ebgp-requires-policy
 no bgp default ipv4-unicast
 
"""
        for i in range(1, self.tunnel_count + 1):
            # Use configured AWS inside IP or default
            aws_inside_ip = self.aws_inside_ips[i-1] if i-1 < len(self.aws_inside_ips) else f"169.254.{10+i}.2"
            
            config += f""" neighbor {aws_inside_ip} remote-as {self.aws_asn}
 neighbor {aws_inside_ip} timers 10 30 30
 neighbor {aws_inside_ip} timers connect 10
 neighbor {aws_inside_ip} description AWS-Tunnel{i}
 
"""
        
        config += """ address-family ipv4 unicast
"""
        for i in range(1, self.tunnel_count + 1):
            aws_inside_ip = self.aws_inside_ips[i-1] if i-1 < len(self.aws_inside_ips) else f"169.254.{10+i}.2"
            
            config += f"""  neighbor {aws_inside_ip} activate
  neighbor {aws_inside_ip} soft-reconfiguration inbound
  neighbor {aws_inside_ip} disable-connected-check
"""
        
        config += """ exit-address-family
exit

"""
        # Add static routes for AWS inside IPs to ensure return traffic routing
        for i in range(1, self.tunnel_count + 1):
            aws_inside_ip = self.aws_inside_ips[i-1] if i-1 < len(self.aws_inside_ips) else f"169.254.{10+i}.2"
            config += f"""ip route {aws_inside_ip}/32 vti{i}
"""
        
        config += """
line vty
exit
"""
        return config
    
    def _generate_vti_script(self) -> str:
        """Generate VTI setup script"""
        script = """#!/bin/bash
# VTI Interface Setup - Generated by VPN Manager

set -e

echo "Setting up VTI interfaces..."

"""
        # Collect all inside IP subnets for policy routing
        inside_subnets = []
        
        for i, aws_ip in enumerate(self.aws_peer_ips, 1):
            # Use configured on-premises inside IP or default
            onprem_inside_ip = self.onprem_inside_ips[i-1] if i-1 < len(self.onprem_inside_ips) else f"169.254.{10+i}.1"
            aws_inside_ip = self.aws_inside_ips[i-1] if i-1 < len(self.aws_inside_ips) else f"169.254.{10+i}.2"
            
            # Calculate /30 subnet from on-prem inside IP
            # For 169.254.55.54, subnet is 169.254.55.52/30
            ip_parts = onprem_inside_ip.split('.')
            last_octet = int(ip_parts[3])
            subnet_base = (last_octet // 4) * 4  # Round down to nearest multiple of 4
            subnet = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.{subnet_base}/30"
            inside_subnets.append(subnet)
            
            script += f"""
# Tunnel {i}
# AWS Inside IP: {aws_inside_ip}
# On-Prem Inside IP: {onprem_inside_ip}
ip tunnel add vti{i} mode vti local 0.0.0.0 remote {aws_ip} key {i} || true
ip addr add {onprem_inside_ip}/30 dev vti{i} || true
ip link set vti{i} up mtu 1419
sysctl -w net.ipv4.conf.vti{i}.disable_policy=1
sysctl -w net.ipv4.conf.vti{i}.rp_filter=2

"""
        
        # Add policy routing rules for AWS EC2 instances
        script += """
echo "Configuring policy routing rules..."

# Remove any existing rules (ignore errors)
"""
        for subnet in inside_subnets:
            script += f"ip rule del to {subnet} table main priority 100 2>/dev/null || true\n"
        
        script += """
# Add policy routing rules to force BGP traffic through VTI interfaces
# This is required on AWS EC2 instances where table 220 overrides main table
"""
        for subnet in inside_subnets:
            script += f"ip rule add to {subnet} table main priority 100\n"
        
        script += """
# Flush route cache to apply changes
ip route flush cache

echo "VTI interfaces configured successfully!"
echo "Policy routing rules applied for AWS EC2 compatibility"
"""
        return script
    
    def _generate_updown_script(self) -> str:
        """Generate IPsec updown script"""
        return """#!/bin/bash
# IPsec Updown Script - Generated by VPN Manager

set -e

VTI_IF="vti${PLUTO_MARK_OUT}"

case "${PLUTO_VERB}" in
    up-client)
        ip link set ${VTI_IF} up
        # Trigger connectivity test
        /usr/local/bin/vpn_manager.py --test-connectivity &
        ;;
    down-client)
        ip link set ${VTI_IF} down
        ;;
esac
"""


class ConnectivityTester:
    """Automated connectivity testing"""
    
    def __init__(self, config: VPNConfig):
        self.config = config
        self.results = {}
    
    def test_all(self) -> Dict:
        """Test connectivity to all remote networks"""
        results = {
            'timestamp': datetime.now().isoformat(),
            'tests': [],
            'summary': {'total': 0, 'passed': 0, 'failed': 0}
        }
        
        for network in self.config.remote_networks:
            test_result = self._test_network(network)
            results['tests'].append(test_result)
            results['summary']['total'] += 1
            
            if test_result['success']:
                results['summary']['passed'] += 1
            else:
                results['summary']['failed'] += 1
        
        self.results = results
        return results
    
    def _test_network(self, network: str) -> Dict:
        """Test connectivity to a specific network"""
        # Extract IP from CIDR if needed
        test_ip = network.split('/')[0]
        
        result = {
            'network': network,
            'test_ip': test_ip,
            'timestamp': datetime.now().isoformat(),
            'success': False,
            'latency_ms': None,
            'packet_loss': None,
            'error': None
        }
        
        try:
            # Ping test
            cmd = ['ping', '-c', '3', '-W', '2', test_ip]
            process = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                timeout=10
            )
            
            if process.returncode == 0:
                result['success'] = True
                
                # Parse latency
                latency_match = re.search(r'rtt min/avg/max/mdev = [\d.]+/([\d.]+)/', process.stdout)
                if latency_match:
                    result['latency_ms'] = float(latency_match.group(1))
                
                # Parse packet loss
                loss_match = re.search(r'(\d+)% packet loss', process.stdout)
                if loss_match:
                    result['packet_loss'] = int(loss_match.group(1))
            else:
                result['error'] = 'Ping failed'
        
        except subprocess.TimeoutExpired:
            result['error'] = 'Timeout'
        except Exception as e:
            result['error'] = str(e)
        
        return result




class HealthMonitor:
    """VPN health monitoring and issue detection"""
    
    def __init__(self, config: VPNConfig):
        self.config = config
        self.issues = []
    
    def check_health(self) -> Dict:
        """Perform comprehensive health check"""
        health = {
            'timestamp': datetime.now().isoformat(),
            'status': 'healthy',
            'checks': {},
            'issues': [],
            'metrics': {}
        }
        
        # Check IPsec tunnels
        health['checks']['ipsec'] = self._check_ipsec()
        
        # Check BGP sessions
        health['checks']['bgp'] = self._check_bgp()
        
        # Check VTI interfaces
        health['checks']['vti'] = self._check_vti()
        
        # Check routing
        health['checks']['routing'] = self._check_routing()
        
        # Analyze logs for issues
        health['checks']['logs'] = self._analyze_logs()
        
        # Collect all issues
        for check_name, check_result in health['checks'].items():
            if check_result.get('issues'):
                health['issues'].extend(check_result['issues'])
        
        # Determine overall status
        if health['issues']:
            critical = [i for i in health['issues'] if i.get('severity') == 'critical']
            health['status'] = 'critical' if critical else 'degraded'
        
        self.issues = health['issues']
        return health
    
    def _check_ipsec(self) -> Dict:
        """Check IPsec tunnel status"""
        result = {'status': 'unknown', 'tunnels': [], 'issues': []}
        
        try:
            process = subprocess.run(
                ['ipsec', 'status'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                timeout=10
            )
            
            output = process.stdout
            
            # Check each tunnel
            for i in range(1, self.config.tunnel_count + 1):
                tunnel_name = f'Tunnel{i}'
                
                if f'{tunnel_name}[' in output and 'ESTABLISHED' in output:
                    result['tunnels'].append({
                        'name': tunnel_name,
                        'status': 'up'
                    })
                else:
                    result['tunnels'].append({
                        'name': tunnel_name,
                        'status': 'down'
                    })
                    result['issues'].append({
                        'type': 'tunnel_down',
                        'severity': 'critical',
                        'tunnel': tunnel_name,
                        'message': f'IPsec tunnel {tunnel_name} is down'
                    })
            
            result['status'] = 'healthy' if not result['issues'] else 'degraded'
        
        except Exception as e:
            result['status'] = 'error'
            result['error'] = str(e)
        
        return result
    
    def _check_bgp(self) -> Dict:
        """Check BGP session status"""
        result = {'status': 'unknown', 'neighbors': [], 'issues': []}
        
        try:
            process = subprocess.run(
                ['vtysh', '-c', 'show bgp summary'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                timeout=10
            )
            
            output = process.stdout
            
            # Parse BGP neighbors
            for line in output.split('\n'):
                if re.match(r'^\d+\.\d+\.\d+\.\d+', line):
                    parts = line.split()
                    if len(parts) >= 10:
                        neighbor_ip = parts[0]
                        state = parts[9]
                        
                        neighbor = {
                            'ip': neighbor_ip,
                            'state': state
                        }
                        result['neighbors'].append(neighbor)
                        
                        if state != 'Established' and not state.isdigit():
                            result['issues'].append({
                                'type': 'bgp_down',
                                'severity': 'critical',
                                'neighbor': neighbor_ip,
                                'message': f'BGP neighbor {neighbor_ip} not established (state: {state})'
                            })
            
            result['status'] = 'healthy' if not result['issues'] else 'degraded'
        
        except Exception as e:
            result['status'] = 'error'
            result['error'] = str(e)
        
        return result
    
    def _check_vti(self) -> Dict:
        """Check VTI interface status"""
        result = {'status': 'unknown', 'interfaces': [], 'issues': []}
        
        try:
            process = subprocess.run(
                ['ip', 'link', 'show'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                timeout=5
            )
            
            output = process.stdout
            
            for i in range(1, self.config.tunnel_count + 1):
                vti_name = f'vti{i}'
                
                if vti_name in output:
                    # Check if UP
                    is_up = f'{vti_name}:' in output and 'state UP' in output
                    
                    result['interfaces'].append({
                        'name': vti_name,
                        'status': 'up' if is_up else 'down'
                    })
                    
                    if not is_up:
                        result['issues'].append({
                            'type': 'vti_down',
                            'severity': 'high',
                            'interface': vti_name,
                            'message': f'VTI interface {vti_name} is down'
                        })
                else:
                    result['interfaces'].append({
                        'name': vti_name,
                        'status': 'missing'
                    })
                    result['issues'].append({
                        'type': 'vti_missing',
                        'severity': 'critical',
                        'interface': vti_name,
                        'message': f'VTI interface {vti_name} is missing'
                    })
            
            result['status'] = 'healthy' if not result['issues'] else 'degraded'
        
        except Exception as e:
            result['status'] = 'error'
            result['error'] = str(e)
        
        return result
    
    def _check_routing(self) -> Dict:
        """Check routing table"""
        result = {'status': 'unknown', 'routes': 0, 'issues': []}
        
        try:
            process = subprocess.run(
                ['ip', 'route', 'show'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                timeout=5
            )
            
            output = process.stdout
            
            # Count VTI routes
            vti_routes = [line for line in output.split('\n') if 'vti' in line]
            result['routes'] = len(vti_routes)
            
            if result['routes'] == 0:
                result['issues'].append({
                    'type': 'no_routes',
                    'severity': 'high',
                    'message': 'No routes via VTI interfaces found'
                })
            
            result['status'] = 'healthy' if not result['issues'] else 'degraded'
        
        except Exception as e:
            result['status'] = 'error'
            result['error'] = str(e)
        
        return result
    
    def _analyze_logs(self) -> Dict:
        """Analyze recent VPN logs for issues"""
        result = {'status': 'unknown', 'issues': []}
        
        try:
            # Get recent logs
            process = subprocess.run(
                ['journalctl', '-u', 'strongswan', '-u', 'frr', '-n', '100', '--no-pager'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                timeout=10
            )
            
            logs = process.stdout
            
            # Check for authentication failures
            if 'authentication' in logs.lower() and 'failed' in logs.lower():
                result['issues'].append({
                    'type': 'auth_failure',
                    'severity': 'critical',
                    'message': 'Authentication failures detected in logs',
                    'fix': 'Check PSK configuration in /etc/ipsec.secrets'
                })
            
            # Check for no proposal chosen
            if 'no proposal chosen' in logs.lower():
                result['issues'].append({
                    'type': 'proposal_mismatch',
                    'severity': 'critical',
                    'message': 'Encryption proposal mismatch detected',
                    'fix': 'Verify encryption algorithms match AWS configuration'
                })
            
            # Check for connection refused
            if 'connection refused' in logs.lower():
                result['issues'].append({
                    'type': 'connection_refused',
                    'severity': 'high',
                    'message': 'Connection refused errors detected',
                    'fix': 'Check VTI interfaces and BGP configuration'
                })
            
            result['status'] = 'healthy' if not result['issues'] else 'degraded'
        
        except Exception as e:
            result['status'] = 'error'
            result['error'] = str(e)
        
        return result


class AutoRemediation:
    """Automated issue remediation"""
    
    def __init__(self, config: VPNConfig):
        self.config = config
        self.actions_taken = []
    
    def remediate(self, issues: List[Dict]) -> Dict:
        """Attempt to automatically fix detected issues"""
        result = {
            'timestamp': datetime.now().isoformat(),
            'issues_processed': len(issues),
            'actions_taken': [],
            'fixed': [],
            'failed': []
        }
        
        for issue in issues:
            action = self._remediate_issue(issue)
            result['actions_taken'].append(action)
            
            if action['success']:
                result['fixed'].append(issue['type'])
            else:
                result['failed'].append(issue['type'])
        
        self.actions_taken = result['actions_taken']
        return result
    
    def _remediate_issue(self, issue: Dict) -> Dict:
        """Remediate a specific issue"""
        action = {
            'issue_type': issue['type'],
            'timestamp': datetime.now().isoformat(),
            'success': False,
            'action': None,
            'error': None
        }
        
        issue_type = issue['type']
        
        if issue_type == 'tunnel_down':
            action['action'] = 'restart_ipsec'
            action['success'] = self._restart_ipsec()
        
        elif issue_type == 'bgp_down':
            action['action'] = 'restart_frr'
            action['success'] = self._restart_frr()
        
        elif issue_type == 'vti_down':
            action['action'] = 'bring_up_vti'
            vti_name = issue.get('interface', 'vti1')
            action['success'] = self._bring_up_vti(vti_name)
        
        elif issue_type == 'vti_missing':
            action['action'] = 'create_vti'
            action['success'] = self._setup_vti_interfaces()
        
        elif issue_type == 'no_routes':
            action['action'] = 'restart_bgp'
            action['success'] = self._restart_frr()
        
        else:
            action['action'] = 'manual_intervention_required'
            action['error'] = f'No automated fix available for {issue_type}'
        
        return action
    
    def _restart_ipsec(self) -> bool:
        """Restart IPsec service"""
        try:
            subprocess.run(['systemctl', 'restart', 'strongswan'], check=True, timeout=30)
            time.sleep(5)  # Wait for service to start
            return True
        except:
            return False
    
    def _restart_frr(self) -> bool:
        """Restart FRR service"""
        try:
            subprocess.run(['systemctl', 'restart', 'frr'], check=True, timeout=30)
            time.sleep(5)
            return True
        except:
            return False
    
    def _bring_up_vti(self, vti_name: str) -> bool:
        """Bring up VTI interface"""
        try:
            subprocess.run(['ip', 'link', 'set', vti_name, 'up'], check=True, timeout=5)
            return True
        except:
            return False
    
    def _setup_vti_interfaces(self) -> bool:
        """Setup all VTI interfaces"""
        try:
            subprocess.run(['/etc/vpn/setup_vti.sh'], check=True, timeout=30)
            return True
        except:
            return False


class EmailNotifier:
    """Email notification system"""
    
    def __init__(self, config_file: str = '/etc/vpn/email_config.json'):
        self.config = self._load_config(config_file)
    
    def _load_config(self, config_file: str) -> Dict:
        """Load email configuration"""
        default_config = {
            'enabled': False,
            'smtp_server': 'localhost',
            'smtp_port': 25,
            'use_tls': False,
            'username': None,
            'password': None,
            'from_addr': 'vpn-manager@localhost',
            'to_addrs': [],
            'subject_prefix': '[VPN Manager]'
        }
        
        try:
            with open(config_file, 'r') as f:
                user_config = json.load(f)
            default_config.update(user_config)
        except:
            pass
        
        return default_config
    
    def send_alert(self, subject: str, body: str, severity: str = 'info') -> bool:
        """Send email alert"""
        if not self.config['enabled']:
            return False
        
        if not self.config['to_addrs']:
            return False
        
        try:
            # Create message
            msg = MIMEMultipart()
            msg['From'] = self.config['from_addr']
            msg['To'] = ', '.join(self.config['to_addrs'])
            msg['Subject'] = f"{self.config['subject_prefix']} [{severity.upper()}] {subject}"
            
            # Add body
            msg.attach(MIMEText(body, 'plain'))
            
            # Send email
            if self.config['use_tls']:
                server = smtplib.SMTP(self.config['smtp_server'], self.config['smtp_port'])
                server.starttls()
            else:
                server = smtplib.SMTP(self.config['smtp_server'], self.config['smtp_port'])
            
            if self.config['username'] and self.config['password']:
                server.login(self.config['username'], self.config['password'])
            
            server.send_message(msg)
            server.quit()
            
            return True
        
        except Exception as e:
            print(f"Failed to send email: {e}")
            return False
    
    def send_health_report(self, health: Dict, connectivity: Dict = None):
        """Send health check report"""
        subject = f"VPN Health Status: {health['status'].upper()}"
        
        body = f"""VPN Health Report
================================================================================
Timestamp: {health['timestamp']}
Status: {health['status'].upper()}

"""
        
        # Issues
        if health['issues']:
            body += f"\nISSUES DETECTED ({len(health['issues'])}):\n"
            body += "-" * 80 + "\n"
            for issue in health['issues']:
                body += f"[{issue['severity'].upper()}] {issue['message']}\n"
                if issue.get('fix'):
                    body += f"  Fix: {issue['fix']}\n"
            body += "\n"
        
        # Connectivity
        if connectivity:
            body += f"\nCONNECTIVITY TESTS:\n"
            body += "-" * 80 + "\n"
            body += f"Total: {connectivity['summary']['total']}\n"
            body += f"Passed: {connectivity['summary']['passed']}\n"
            body += f"Failed: {connectivity['summary']['failed']}\n\n"
            
            for test in connectivity['tests']:
                status = "‚úì" if test['success'] else "‚úó"
                body += f"{status} {test['network']}: "
                if test['success']:
                    body += f"{test['latency_ms']}ms\n"
                else:
                    body += f"FAILED - {test.get('error', 'Unknown')}\n"
        
        body += "\n" + "=" * 80 + "\n"
        
        severity = 'critical' if health['status'] == 'critical' else 'warning' if health['status'] == 'degraded' else 'info'
        self.send_alert(subject, body, severity)




class VPNManager:
    """Main VPN Manager orchestrator"""
    
    def __init__(self, config_file: str = '/etc/vpn/config.json'):
        self.config_file = config_file
        self.config = VPNConfig()
        
        if Path(config_file).exists():
            self.config.load_from_file(config_file)
        
        self.health_monitor = HealthMonitor(self.config)
        self.connectivity_tester = ConnectivityTester(self.config)
        self.auto_remediation = AutoRemediation(self.config)
        self.email_notifier = EmailNotifier()
    
    def setup(self, interactive: bool = True):
        """Initial VPN setup"""
        print("\n" + "="*80)
        print("üîß VPN MANAGER - INITIAL SETUP")
        print("="*80)
        
        # Check and install prerequisites
        print("\nüì¶ Checking prerequisites...")
        self._check_and_install_prerequisites()
        
        if interactive:
            self._gather_config_interactive()
        
        # Generate configurations
        print("\nüìù Generating VPN configurations...")
        self.config.generate_configs()
        print("‚úÖ Configuration files generated in /etc/vpn/")
        
        # Save config
        self.config.save_to_file(self.config_file)
        print(f"‚úÖ Configuration saved to {self.config_file}")
        
        # Deploy configurations to system locations
        print("\nüìã Deploying configurations...")
        self._deploy_configs()
        
        # Setup VTI interfaces
        print("\nüîó Setting up VTI interfaces...")
        try:
            subprocess.run(['/etc/vpn/setup_vti.sh'], check=True, timeout=30)
            print("‚úÖ VTI interfaces configured")
        except Exception as e:
            print(f"‚ö†Ô∏è  Failed to setup VTI interfaces: {e}")
        
        # Restart services
        print("\nüîÑ Restarting services...")
        self._restart_services()
        
        # Wait for services to stabilize
        print("\n‚è≥ Waiting for services to stabilize...")
        time.sleep(5)
        
        # Show initial status
        print("\nüìä Initial Status Check:")
        self._show_quick_status()
        
        print("\n‚úÖ VPN setup complete!")
        print("\nüí° Next steps:")
        print("  1. Verify tunnels: sudo ipsec status")
        print("  2. Check BGP: sudo vtysh -c 'show bgp summary'")
        print("  3. Run health check: vpn_manager.py --monitor")
        print("  4. View logs: sudo journalctl -u strongswan -f")
    
    def _check_and_install_prerequisites(self):
        """Check and install required packages"""
        required_packages = {
            'strongswan': 'strongswan',
            'frr': 'frr',
            'vtysh': 'frr'
        }
        
        missing = []
        for cmd, package in required_packages.items():
            try:
                subprocess.run(['which', cmd], check=True, capture_output=True, timeout=5)
                print(f"  ‚úÖ {cmd} is installed")
            except:
                missing.append(package)
                print(f"  ‚ö†Ô∏è  {cmd} is not installed")
        
        if missing:
            print(f"\nüì¶ Installing missing packages: {', '.join(set(missing))}")
            try:
                # Check if FRR needs special handling
                need_frr = 'frr' in missing
                
                if need_frr:
                    # Check Ubuntu version
                    try:
                        result = subprocess.run(
                            ['lsb_release', '-rs'],
                            capture_output=True,
                            text=True,
                            timeout=5
                        )
                        ubuntu_version = result.stdout.strip()
                    except:
                        ubuntu_version = "unknown"
                    
                    print(f"  üìù Detected Ubuntu {ubuntu_version}")
                    
                    # For Ubuntu 18.04, add FRR repository
                    if ubuntu_version == "18.04":
                        print("  üìù Adding FRR repository for Ubuntu 18.04...")
                        
                        # Install prerequisites
                        subprocess.run(
                            ['apt-get', 'install', '-y', 'curl', 'gnupg', 'lsb-release'],
                            check=True,
                            timeout=120
                        )
                        
                        # Add FRR GPG key
                        subprocess.run(
                            'curl -s https://deb.frrouting.org/frr/keys.asc | apt-key add -',
                            shell=True,
                            check=True,
                            timeout=30
                        )
                        
                        # Add FRR repository
                        with open('/etc/apt/sources.list.d/frr.list', 'w') as f:
                            f.write(f'deb https://deb.frrouting.org/frr bionic frr-stable\n')
                        
                        print("  ‚úÖ FRR repository added")
                
                # Update package list
                subprocess.run(['apt-get', 'update'], check=True, timeout=120)
                
                # Install packages
                packages_to_install = list(set(missing))
                if need_frr and 'frr' in packages_to_install:
                    # Install FRR with pythontools
                    packages_to_install.remove('frr')
                    packages_to_install.extend(['frr', 'frr-pythontools'])
                
                subprocess.run(
                    ['apt-get', 'install', '-y'] + packages_to_install,
                    check=True,
                    timeout=300
                )
                print("‚úÖ Packages installed successfully")
                
                # Enable BGP in FRR if FRR was installed
                if need_frr:
                    print("  üìù Enabling BGP in FRR...")
                    try:
                        with open('/etc/frr/daemons', 'r') as f:
                            content = f.read()
                        
                        content = content.replace('bgpd=no', 'bgpd=yes')
                        
                        with open('/etc/frr/daemons', 'w') as f:
                            f.write(content)
                        
                        print("  ‚úÖ BGP enabled in FRR")
                    except Exception as e:
                        print(f"  ‚ö†Ô∏è  Could not enable BGP: {e}")
                
                # Enable and start services
                for service in ['strongswan', 'frr']:
                    try:
                        subprocess.run(['systemctl', 'enable', service], check=True, timeout=10)
                        subprocess.run(['systemctl', 'start', service], check=True, timeout=30)
                        print(f"  ‚úÖ {service} enabled and started")
                    except:
                        print(f"  ‚ö†Ô∏è  Could not start {service}")
                
            except subprocess.TimeoutExpired:
                print("‚ö†Ô∏è  Package installation timed out")
            except Exception as e:
                print(f"‚ö†Ô∏è  Failed to install packages: {e}")
                print("Please install manually:")
                print(f"  # For Ubuntu 18.04:")
                print(f"  curl -s https://deb.frrouting.org/frr/keys.asc | sudo apt-key add -")
                print(f"  echo 'deb https://deb.frrouting.org/frr bionic frr-stable' | sudo tee /etc/apt/sources.list.d/frr.list")
                print(f"  sudo apt-get update")
                print(f"  sudo apt-get install -y strongswan frr frr-pythontools")
        else:
            print("‚úÖ All prerequisites are installed")
    
    def _deploy_configs(self):
        """Deploy generated configs to system locations"""
        deployments = [
            ('/etc/vpn/ipsec.conf', '/etc/ipsec.conf', 0o644),
            ('/etc/vpn/ipsec.secrets', '/etc/ipsec.secrets', 0o600),
            ('/etc/vpn/frr.conf', '/etc/frr/frr.conf', 0o640),
            ('/etc/vpn/aws-updown.sh', '/etc/ipsec.d/aws-updown.sh', 0o755),
        ]
        
        for source, dest, perms in deployments:
            try:
                if Path(source).exists():
                    # Create destination directory if needed
                    Path(dest).parent.mkdir(parents=True, exist_ok=True)
                    
                    # Copy file
                    subprocess.run(['cp', source, dest], check=True, timeout=5)
                    
                    # Set permissions
                    os.chmod(dest, perms)
                    
                    # Set ownership for FRR config
                    if 'frr.conf' in dest:
                        try:
                            subprocess.run(['chown', 'frr:frr', dest], check=True, timeout=5)
                        except:
                            pass
                    
                    print(f"  ‚úÖ Deployed {Path(dest).name}")
                else:
                    print(f"  ‚ö†Ô∏è  Source file not found: {source}")
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Failed to deploy {Path(dest).name}: {e}")
    
    def _restart_services(self):
        """Restart VPN services"""
        services = ['strongswan', 'frr']
        
        for service in services:
            try:
                subprocess.run(['systemctl', 'restart', service], check=True, timeout=30)
                print(f"  ‚úÖ {service} restarted")
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Failed to restart {service}: {e}")
    
    def _show_quick_status(self):
        """Show quick status summary"""
        # Check IPsec
        try:
            result = subprocess.run(
                ['ipsec', 'status'],
                capture_output=True,
                text=True,
                timeout=10
            )
            tunnel_count = result.stdout.count('ESTABLISHED')
            if tunnel_count > 0:
                print(f"  ‚úÖ IPsec: {tunnel_count} tunnel(s) established")
            else:
                print(f"  ‚ö†Ô∏è  IPsec: No tunnels established yet (may take a few moments)")
        except:
            print("  ‚ö†Ô∏è  IPsec: Could not check status")
        
        # Check BGP
        try:
            result = subprocess.run(
                ['vtysh', '-c', 'show bgp summary'],
                capture_output=True,
                text=True,
                timeout=10
            )
            if 'Established' in result.stdout:
                established = result.stdout.count('Established')
                print(f"  ‚úÖ BGP: {established} session(s) established")
            else:
                print(f"  ‚ö†Ô∏è  BGP: No sessions established yet (may take a few moments)")
        except:
            print("  ‚ö†Ô∏è  BGP: Could not check status")
        
        # Check VTI
        try:
            result = subprocess.run(
                ['ip', 'link', 'show'],
                capture_output=True,
                text=True,
                timeout=5
            )
            vti_count = result.stdout.count('vti')
            if vti_count > 0:
                print(f"  ‚úÖ VTI: {vti_count} interface(s) configured")
            else:
                print(f"  ‚ö†Ô∏è  VTI: No interfaces found")
        except:
            print("  ‚ö†Ô∏è  VTI: Could not check status")
    
    def _gather_config_interactive(self):
        """Interactive configuration gathering"""
        print("\nProvide VPN configuration:\n")
        
        self.config.vpn_id = input("AWS VPN Connection ID: ").strip()
        
        print("\nüìç Outside IP Addresses (Public IPs):")
        aws_ips = input("AWS peer outside IPs (comma-separated): ").strip()
        self.config.aws_peer_ips = [ip.strip() for ip in aws_ips.split(',')]
        
        self.config.onprem_peer_ip = input("On-premises outside IP: ").strip()
        
        print("\nüìç Inside IP Addresses (BGP Peering - 169.254.x.x):")
        print("These are the /30 CIDR blocks for BGP peering inside the tunnels")
        
        self.config.aws_inside_ips = []
        self.config.onprem_inside_ips = []
        
        for i in range(1, len(self.config.aws_peer_ips) + 1):
            print(f"\nTunnel {i}:")
            aws_inside = input(f"  AWS inside IP (e.g., 169.254.{10+i}.2): ").strip()
            if not aws_inside:
                aws_inside = f"169.254.{10+i}.2"
            self.config.aws_inside_ips.append(aws_inside)
            
            onprem_inside = input(f"  On-premises inside IP (e.g., 169.254.{10+i}.1): ").strip()
            if not onprem_inside:
                onprem_inside = f"169.254.{10+i}.1"
            self.config.onprem_inside_ips.append(onprem_inside)
        
        print("\nüì° BGP Configuration:")
        aws_asn = input("AWS ASN [64512]: ").strip()
        self.config.aws_asn = int(aws_asn) if aws_asn else 64512
        
        onprem_asn = input("On-premises ASN [65000]: ").strip()
        self.config.onprem_asn = int(onprem_asn) if onprem_asn else 65000
        
        print("\nüåê Remote Networks:")
        networks = input("Remote networks to monitor (comma-separated CIDRs): ").strip()
        if networks:
            self.config.remote_networks = [n.strip() for n in networks.split(',')]
        
        # PSK configuration
        print("\nüîê Pre-Shared Keys:")
        for i in range(1, len(self.config.aws_peer_ips) + 1):
            psk = input(f"PSK for Tunnel{i}: ").strip()
            if psk:
                self.config.psk[f'tunnel{i}'] = psk
    
    def monitor(self, auto_fix: bool = True, notify: bool = True):
        """Run health monitoring cycle"""
        print("\n" + "="*80)
        print("üè• VPN HEALTH MONITORING")
        print("="*80)
        print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        
        # Health check
        print("üîç Performing health checks...")
        health = self.health_monitor.check_health()
        
        # Display status
        status_icon = "‚úÖ" if health['status'] == 'healthy' else "‚ö†Ô∏è" if health['status'] == 'degraded' else "‚ùå"
        print(f"\n{status_icon} Overall Status: {health['status'].upper()}")
        
        # Display issues
        if health['issues']:
            print(f"\nüö® Issues Detected: {len(health['issues'])}")
            for issue in health['issues']:
                severity_icon = "‚ùå" if issue['severity'] == 'critical' else "‚ö†Ô∏è"
                print(f"  {severity_icon} [{issue['severity'].upper()}] {issue['message']}")
        
        # Connectivity tests
        print("\nüîó Testing connectivity...")
        connectivity = self.connectivity_tester.test_all()
        
        print(f"  Total tests: {connectivity['summary']['total']}")
        print(f"  Passed: {connectivity['summary']['passed']}")
        print(f"  Failed: {connectivity['summary']['failed']}")
        
        if connectivity['summary']['failed'] > 0:
            print("\n  Failed tests:")
            for test in connectivity['tests']:
                if not test['success']:
                    print(f"    ‚úó {test['network']}: {test.get('error', 'Unknown')}")
        
        # Auto-remediation
        if auto_fix and health['issues']:
            print("\nüîß Attempting auto-remediation...")
            remediation = self.auto_remediation.remediate(health['issues'])
            
            print(f"  Actions taken: {len(remediation['actions_taken'])}")
            print(f"  Fixed: {len(remediation['fixed'])}")
            print(f"  Failed: {len(remediation['failed'])}")
            
            if remediation['fixed']:
                print("\n  Fixed issues:")
                for issue_type in remediation['fixed']:
                    print(f"    ‚úì {issue_type}")
            
            if remediation['failed']:
                print("\n  Failed to fix:")
                for issue_type in remediation['failed']:
                    print(f"    ‚úó {issue_type}")
            
            # Re-check health after remediation
            if remediation['fixed']:
                print("\nüîç Re-checking health after remediation...")
                time.sleep(10)  # Wait for services to stabilize
                health = self.health_monitor.check_health()
                status_icon = "‚úÖ" if health['status'] == 'healthy' else "‚ö†Ô∏è" if health['status'] == 'degraded' else "‚ùå"
                print(f"  {status_icon} New Status: {health['status'].upper()}")
        
        # Email notification
        if notify and (health['issues'] or connectivity['summary']['failed'] > 0):
            print("\nüìß Sending email notification...")
            if self.email_notifier.send_health_report(health, connectivity):
                print("  ‚úÖ Email sent")
            else:
                print("  ‚ö†Ô∏è  Email not configured or failed to send")
        
        # Save report
        report_file = f"/var/log/vpn_health_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        report = {
            'health': health,
            'connectivity': connectivity
        }
        
        try:
            with open(report_file, 'w') as f:
                json.dump(report, f, indent=2, default=str)
            print(f"\nüìÑ Report saved to: {report_file}")
        except:
            print(f"\n‚ö†Ô∏è  Could not save report to {report_file}")
        
        print("\n" + "="*80)
        
        return health, connectivity
    
    def test_connectivity(self):
        """Test connectivity only"""
        print("\nüîó Testing connectivity to remote networks...")
        results = self.connectivity_tester.test_all()
        
        for test in results['tests']:
            status = "‚úì" if test['success'] else "‚úó"
            print(f"{status} {test['network']}: ", end='')
            if test['success']:
                print(f"{test['latency_ms']}ms (loss: {test['packet_loss']}%)")
            else:
                print(f"FAILED - {test.get('error', 'Unknown')}")
        
        print(f"\nSummary: {results['summary']['passed']}/{results['summary']['total']} passed")
        
        return results
    
    def status(self):
        """Show current VPN status"""
        print("\n" + "="*80)
        print("üìä VPN STATUS")
        print("="*80)
        
        # IPsec status
        print("\nüîê IPsec Tunnels:")
        try:
            result = subprocess.run(['ipsec', 'status'], capture_output=True, text=True, timeout=10)
            for line in result.stdout.split('\n'):
                if 'ESTABLISHED' in line or 'Tunnel' in line:
                    print(f"  {line}")
        except:
            print("  ‚ö†Ô∏è  Could not retrieve IPsec status")
        
        # BGP status
        print("\nüåê BGP Sessions:")
        try:
            result = subprocess.run(['vtysh', '-c', 'show bgp summary'], capture_output=True, text=True, timeout=10)
            for line in result.stdout.split('\n'):
                if re.match(r'^\d+\.\d+\.\d+\.\d+', line):
                    print(f"  {line}")
        except:
            print("  ‚ö†Ô∏è  Could not retrieve BGP status")
        
        # VTI interfaces
        print("\nüîó VTI Interfaces:")
        try:
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True, timeout=5)
            for line in result.stdout.split('\n'):
                if 'vti' in line:
                    print(f"  {line}")
        except:
            print("  ‚ö†Ô∏è  Could not retrieve VTI status")
        
        print("\n" + "="*80)


def main():
    parser = argparse.ArgumentParser(
        description='AWS Site-to-Site VPN Manager - Configuration, Monitoring & Auto-Remediation',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Initial setup
  sudo vpn_manager.py --setup --interactive
  
  # Run health monitoring with auto-fix
  sudo vpn_manager.py --monitor --auto-fix --notify
  
  # Test connectivity only
  vpn_manager.py --test-connectivity
  
  # Show current status
  vpn_manager.py --status
  
  # Run as daemon (continuous monitoring)
  sudo vpn_manager.py --daemon --interval 300
        """
    )
    
    parser.add_argument('--setup', action='store_true',
                       help='Initial VPN setup and configuration')
    parser.add_argument('--monitor', action='store_true',
                       help='Run health monitoring')
    parser.add_argument('--test-connectivity', action='store_true',
                       help='Test connectivity to remote networks')
    parser.add_argument('--status', action='store_true',
                       help='Show current VPN status')
    parser.add_argument('--daemon', action='store_true',
                       help='Run as daemon (continuous monitoring)')
    
    parser.add_argument('--interactive', '-i', action='store_true',
                       help='Interactive mode')
    parser.add_argument('--auto-fix', action='store_true', default=True,
                       help='Enable auto-remediation (default: enabled)')
    parser.add_argument('--no-auto-fix', action='store_false', dest='auto_fix',
                       help='Disable auto-remediation')
    parser.add_argument('--notify', action='store_true', default=True,
                       help='Send email notifications (default: enabled)')
    parser.add_argument('--no-notify', action='store_false', dest='notify',
                       help='Disable email notifications')
    
    parser.add_argument('--config', default='/etc/vpn/config.json',
                       help='Configuration file path')
    parser.add_argument('--interval', type=int, default=300,
                       help='Monitoring interval in seconds (default: 300)')
    
    args = parser.parse_args()
    
    # Initialize manager
    manager = VPNManager(args.config)
    
    if args.setup:
        manager.setup(interactive=args.interactive)
    
    elif args.monitor:
        manager.monitor(auto_fix=args.auto_fix, notify=args.notify)
    
    elif args.test_connectivity:
        manager.test_connectivity()
    
    elif args.status:
        manager.status()
    
    elif args.daemon:
        print(f"üîÑ Starting VPN Manager daemon (interval: {args.interval}s)")
        print("Press Ctrl+C to stop\n")
        
        try:
            while True:
                manager.monitor(auto_fix=args.auto_fix, notify=args.notify)
                print(f"\n‚è∞ Next check in {args.interval} seconds...")
                time.sleep(args.interval)
        except KeyboardInterrupt:
            print("\n\nüëã VPN Manager daemon stopped")
    
    else:
        parser.print_help()


if __name__ == '__main__':
    main()

